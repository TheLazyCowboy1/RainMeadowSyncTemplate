using RainMeadow;

namespace RainMeadowCompat;

/**<summary>
 * Imagine that this State is what gets sent across the internet.
 * More specifically, any fields marked [OnlineField] will be sent.
 * 
 * This class, then, defines 3 things:
 * 1. What data is synced (fields)
 * 2. How this data is set (constructor)
 * 3. How this data is read (UpdateReceived())
 * 
 * You MUST have two constructors:
 * e.g:
 * public RandomizerState() : base(null) { }
 * public RandomizerState(RandomizerData data) : base(data) {
 *  //put initialization code here
 * }
 * </summary>
 */
public abstract class ManuallyUpdatedState : OnlineResource.ResourceData.ResourceDataState
{
    //Tracks when the state was last updated
    [OnlineField]
    ulong LastUpdateTime;
    //Tracks whether this state was generated by the host
    [OnlineField]
    bool IsHost = false;

    /**<summary>
     * You should have a constructor like:
     * public RandomizerState(RandomizerData data) : base(data) { }
     * </summary>
     */
    public ManuallyUpdatedState(ManuallyUpdatedData data) {
        if (data != null)
            LastUpdateTime = data.ResetUpdateTime();

        IsHost = OnlineManager.lobby != null && OnlineManager.lobby.isOwner;
    }

    /**<summary>
     * Do NOT override this function in your own implementation.
     * Instead, use ReceivedUpdate().
     * </summary>
     */
    public override void ReadTo(OnlineResource.ResourceData data, OnlineResource resource)
    {
        ManuallyUpdatedData data1 = (ManuallyUpdatedData)data;

        //return if the state has not yet been updated to a newer time

        //I would prefer this to be > (so it would only update if the new update came AFTER the previous one)
        //however... I don't think I can trust all players' internal clocks to be perfectly synced.
        if (LastUpdateTime != data1.LastUpdateTime)
        {
            //reset data update time, so this won't happen again until
            //the state's info is updated
            data1.LastUpdateTime = LastUpdateTime;

            MeadowCompatSetup.ExtraDebug("More recent state information received!");
            //If I am the host, I should not be receiving others' data
            //So, send my own!
            if (data1.HostControlled && OnlineManager.lobby.isOwner)
            {
                MeadowCompatSetup.ExtraDebug("I'm the host. Regenerating state data.");
                data1.UpdateData();
                return;
            }
            //Do not acknowledge data from clients, whatsoever!
            else if (data1.HostControlled && !IsHost)
            {
                MeadowCompatSetup.ExtraDebug("Received data from a client; ignored.");
                return;
            }

            UpdateReceived(data1, resource);
        }
    }

    /**<summary>
     * Override this function in your implementation.
     * Imagine that this function is called whenever you receive a new packet.
     * Update your mod data here.
     * </summary>
     */
    public abstract void UpdateReceived(ManuallyUpdatedData data, OnlineResource resource);

    /**<summary>
     * You MUST replace this function in your implementation of the State.
     * This will make joining lobbies impossible if kept this way.
     * For example, if I have:
     * public class RandomizerData : ManuallyUpdatedData
     * 
     * This function should be:
     * public override Type GetDataType() => typeof(RandomizerData);
     * </summary>
     */
    //public abstract Type GetDataType();
}
